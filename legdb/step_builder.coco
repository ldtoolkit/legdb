from typing import Optional, Type
import os

import lmdb

from legdb import Database, Entity, Node, Edge
from legdb.step import SourceStep, HasStep, EdgeInStep, EdgeOutStep, EdgeAllStep
from legdb.step import ParallelStep, PynndbFilterStep, PynndbEdgeInStep, PynndbEdgeOutStep, PynndbEdgeAllStep


class StepBuilder:
    def __init__(
            self,
            database: Optional[Database] = None,
            node_cls: Type[Entity] = Node,
            edge_cls: Type[Entity] = Edge,
            page_size: int = 4096,
            n_jobs: int = len(os.sched_getaffinity(0)),
            txn: Optional[lmdb.Transaction] = None,
    ) -> None:
        self._compiled_steps = []
        self._database = database
        self._edge_cls = edge_cls
        self._is_compiled = False
        self._n_jobs = n_jobs
        self._node_cls = node_cls
        self._page_size = page_size
        self._steps = []
        self._txn = txn

    def source(self, what: Type[Entity]) -> StepBuilder:
        if self._steps:
            raise ValueError("Step 'source' should be the first.")

        self._steps.append(SourceStep(what=what))
        return self

    def has(self, **kwargs) -> StepBuilder:
        self._steps.append(HasStep(**kwargs))
        return self

    def edge_in(self, **kwargs) -> StepBuilder:
        self._steps.append(EdgeInStep(**kwargs))
        return self

    def edge_out(self, **kwargs) -> StepBuilder:
        self._steps.append(EdgeOutStep(**kwargs))
        return self

    def edge_all(self, **kwargs) -> StepBuilder:
        self._steps.append(EdgeAllStep(**kwargs))
        return self

    def __repr__(self) -> str:
        return ".".join(repr(step) for step in self._steps)

    def create_parallel_step(self, internal_step_creator):
        return ParallelStep(
            steps=(internal_step_creator() for _ in range(self._n_jobs)),
            n_jobs=self._n_jobs,
            page_size=self._page_size,
        )
    
    match def _compile(self):
        raise NotImplementedError()

    addpattern def _compile(self, (step is SourceStep, )):
        return True, [
            PynndbFilterStep(
                database=self._database, 
                what=step.what, 
                attrs={}, 
                page_size=self._page_size,
                txn=self._txn, 
            )
        ]

    addpattern def _compile(self, (step is EdgeInStep, )):
        return True, [self.create_parallel_step(-> PynndbEdgeInStep(
            database=self._database,
            what=self._edge_cls,
            attrs=step.attrs,
            page_size=self._page_size,
            txn=self._txn,
        ))]

    addpattern def _compile(self, (step is EdgeOutStep, )):
        return True, [self.create_parallel_step(-> PynndbEdgeOutStep(
            database=self._database,
            what=self._edge_cls,
            attrs=step.attrs,
            page_size=self._page_size,
            txn=self._txn,
        ))]

    addpattern def _compile(self, (step is EdgeAllStep, )):
        return True, [self.create_parallel_step(-> PynndbEdgeAllStep(
            database=self._database,
            what=self._edge_cls,
            attrs=step.attrs,
            page_size=self._page_size,
            txn=self._txn,
        ))]

    addpattern def _compile(self, (step0 is PynndbFilterStep, step1 is HasStep)):
        attrs = {**step0.attrs, **step1.attrs}
        return False, [
            PynndbFilterStep(
                database=self._database,
                what=step0.what,
                attrs=attrs,
                page_size=self._page_size,
                txn=self._txn,
            )
        ]

    addpattern def _compile(self, steps):
        return True, steps

    def _compile_all(self) -> None:
        if self._is_compiled:
            return
        self._compiled_steps = []
        max_step_count_for_compiled_step = 2
        steps = self._steps
        for step_count in range(1, max_step_count_for_compiled_step + 1):
            i = 0
            j = i + step_count
            while i < len(steps):
                steps_window = steps[i:j]
                go_forward, new_steps = self._compile(steps_window)
                steps = steps[:i] + new_steps + steps[j:]
                if go_forward:
                    i += 1
                    j += 1
        self._compiled_steps = steps
        self._is_compiled = True

    def __iter__(self):
        self._compile_all()
        last = len(self._compiled_steps) - 1
        exhausted = False
        entities = None
        i = 0
        while not exhausted:
            step = self._compiled_steps[i]
            if i > 0 and entities:
                step.input(entities)
            entities = step.output()
            if not entities:
                i -= 1
                if i < 0:
                    exhausted = True
            else:
                if i < last:
                    i += 1
                    self._compiled_steps[i].reset_iter()
                else:
                    yield from entities
