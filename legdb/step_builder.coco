from typing import Optional, Type
from more_itertools import windowed

import lmdb

from legdb import Database, Entity, Node, Edge
from legdb.step import SourceStep, HasStep, InEStep, OutEStep, PynndbFilterStep, PynndbInEStep, PynndbOutEStep


class StepBuilder:
    def __init__(
            self,
            database: Optional[Database] = None,
            node_cls: Type[Entity] = Node,
            edge_cls: Type[Entity] = Edge,
            txn: Optional[lmdb.Transaction] = None,
    ) -> None:
        self._compiled_steps = []
        self._database = database
        self._edge_cls = edge_cls
        self._is_compiled = False
        self._node_cls = node_cls
        self._steps = []
        self._txn = txn

    def source(self, what: Type[Entity]) -> StepBuilder:
        if self._steps:
            raise ValueError("Step 'source' should be the first.")

        self._steps.append(SourceStep(what=what))
        return self

    def has(self, **kwargs) -> StepBuilder:
        self._steps.append(HasStep(**kwargs))
        return self

    def in_e(self, **kwargs) -> StepBuilder:
        self._steps.append(InEStep(**kwargs))
        return self

    def out_e(self, **kwargs) -> StepBuilder:
        self._steps.append(OutEStep(**kwargs))
        return self

    def __repr__(self) -> str:
        return ".".join(repr(step) for step in self._steps)
    
    match def _compile(self):
        raise NotImplementedError()

    addpattern def _compile(self, (step is SourceStep, )):
        return True, [
            PynndbFilterStep(
                database=self._database, 
                what=step.what, 
                attrs={}, 
                txn=self._txn, 
            )
        ]

    addpattern def _compile(self, (step is InEStep, )):
        return True, [
            PynndbInEStep(
                database=self._database,
                what=self._edge_cls,
                attrs=step.attrs,
                txn=self._txn,
            )
        ]

    addpattern def _compile(self, (step is OutEStep, )):
        return True, [
            PynndbOutEStep(
                database=self._database,
                what=self._edge_cls,
                attrs=step.attrs,
                txn=self._txn,
            )
        ]

    addpattern def _compile(self, (step0 is PynndbFilterStep, step1 is HasStep)):
        attrs = {**step0.attrs, **step1.attrs}
        return False, [
            PynndbFilterStep(
                database=self._database,
                what=step0.what,
                attrs=attrs,
                txn=self._txn,
            )
        ]

    addpattern def _compile(self, steps):
        return True, steps

    def _compile_all(self) -> None:
        if self._is_compiled:
            return
        self._compiled_steps = []
        max_step_count_for_compiled_step = 2
        steps = self._steps
        for step_count in range(1, max_step_count_for_compiled_step + 1):
            i = 0
            j = i + step_count
            while i < len(steps):
                steps_window = steps[i:j]
                go_forward, new_steps = self._compile(steps_window)
                steps = steps[:i] + new_steps + steps[j:]
                if go_forward:
                    i += 1
                    j += 1
        self._compiled_steps = steps
        self._is_compiled = True

    def __iter__(self):
        self._compile_all()
        last = len(self._compiled_steps) - 1
        step_iterators = [iter(step) for step in self._compiled_steps]
        while True:
            entity = None
            try:
                for i, (step, step_iterator) in enumerate(zip(self._compiled_steps, step_iterators)):
                    if entity is not None:
                        step.input(entity)
                    entity = next(step_iterator)
                    if i == last:
                        yield entity
            except StopIteration:
                break
